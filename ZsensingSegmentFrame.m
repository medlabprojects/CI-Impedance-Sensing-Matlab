function [E, EA, mod] = ZsensingSegmentFrame(RGB)
%% ZsensingSegmentFrame  
%  
%
% Auto-generated by colorThresholder app on 04-Feb-2020
% Modified by Trevor Bruns
%------------------------------------------------------

warning('off', 'images:imfindcircles:warnForSmallRadius'); % turn off known warning

%% convert from RGB to HSV

HSV = rgb2hsv(RGB);


%% Thresholds (found using colorThesholder app)

% EA Mask (cyan)
EA.channel1Min = 0.459;
EA.channel1Max = 0.548;
EA.channel2Min = 0.333;
EA.channel2Max = 1.000;
EA.channel3Min = 0.000;
EA.channel3Max = 1.000;

% Modiolus (yellow)
mod.channel1Min = 0.150;
mod.channel1Max = 0.225;
mod.channel2Min = 0.000;
mod.channel2Max = 1.000;
mod.channel3Min = 0.852;
mod.channel3Max = 1.000;

% Electrode 1 (red)
E(1).channel1Min = 0.983;
E(1).channel1Max = 0.008;
E(1).channel2Min = 0.705;
E(1).channel2Max = 1.000;
E(1).channel3Min = 0.622;
E(1).channel3Max = 1.000;

% Electrode 2 (orange)
E(2).channel1Min = 0.030;
E(2).channel1Max = 0.135;
E(2).channel2Min = 0.560;
E(2).channel2Max = 1.000;
E(2).channel3Min = 0.599;
E(2).channel3Max = 1.000;

% Electrode 3 (green)
E(3).channel1Min = 0.333;
E(3).channel1Max = 0.450;
E(3).channel2Min = 0.984;
E(3).channel2Max = 1.000;
E(3).channel3Min = 0.949;
E(3).channel3Max = 1.000;

% Electrode 4 (blue)
E(4).channel1Min = 0.624;
E(4).channel1Max = 0.672;
E(4).channel2Min = 0.958;
E(4).channel2Max = 1.000;
E(4).channel3Min = 0.657;
E(4).channel3Max = 1.000;

% Electrode 5 (magenta)
E(5).channel1Min = 0.771;
E(5).channel1Max = 0.917;
E(5).channel2Min = 0.731;
E(5).channel2Max = 1.000;
E(5).channel3Min = 0.769;
E(5).channel3Max = 1.000;


%% Segment Electrode Markers and Find Centers

for ii=1:length(E)

    % check for hue (channel 1) wrap-around (bounds are 0->1)
    if E(ii).channel1Min > E(ii).channel1Max                                                    
        E_mask = ((HSV(:,:,1) >= E(ii).channel1Min ) | (HSV(:,:,1) <= E(ii).channel1Max)) & ...
                  (HSV(:,:,2) >= E(ii).channel2Min ) & (HSV(:,:,2) <= E(ii).channel2Max)  & ...
                  (HSV(:,:,3) >= E(ii).channel3Min ) & (HSV(:,:,3) <= E(ii).channel3Max);
    else
        E_mask =  (HSV(:,:,1) >= E(ii).channel1Min ) & (HSV(:,:,1) <= E(ii).channel1Max)  & ...
                  (HSV(:,:,2) >= E(ii).channel2Min ) & (HSV(:,:,2) <= E(ii).channel2Max)  & ...
                  (HSV(:,:,3) >= E(ii).channel3Min ) & (HSV(:,:,3) <= E(ii).channel3Max);
    end

    % find a point on the mask boundary
    [ix,iy] = find(E_mask,1);
    
    % create polygon from boundary
    E_boundary = bwtraceboundarymex(E_mask, [ix,iy], 8, 4, -1, true); % bypass input checking and call mex directly to run faster
%     E_boundary = bwtraceboundary(E_mask,[ix,iy],'S');
    E(ii).center = polygonCentroid(E_boundary);

%     % find circles with radius between [3,8]
%     [E(ii).center, E(ii).radii] = imfindcircles(E_mask,[3 6],'Method','TwoStage');         
%     E(ii).center = fliplr(E(ii).center); % must convert from image 'X/Y' coordinates to pixel 'row/column'
end


%% Segment EA Mask

% check for hue (channel 1) wrap-around (bounds are 0->1)
if EA.channel1Min > EA.channel1Max
    EA_mask = ((HSV(:,:,1) >= EA.channel1Min ) | (HSV(:,:,1) <= EA.channel1Max)) & ... 
               (HSV(:,:,2) >= EA.channel2Min ) & (HSV(:,:,2) <= EA.channel2Max)  & ...
               (HSV(:,:,3) >= EA.channel3Min ) & (HSV(:,:,3) <= EA.channel3Max);
else
    EA_mask =  (HSV(:,:,1) >= EA.channel1Min ) & (HSV(:,:,1) <= EA.channel1Max) & ...
               (HSV(:,:,2) >= EA.channel2Min ) & (HSV(:,:,2) <= EA.channel2Max) & ...
               (HSV(:,:,3) >= EA.channel3Min ) & (HSV(:,:,3) <= EA.channel3Max);
end

% find a point on the mask boundary
[ix,iy] = find(EA_mask,1);   

% create polygon from boundary
EA.poly = bwtraceboundarymex(EA_mask, [ix,iy], 8, 4, -1, true); % bypass input checking and call mex directly to run faster
% EA.poly = bwtraceboundary(EA_mask,[ix,iy],'S');
EA.poly_smooth = smoothPolygon(EA.poly, 25);                  


%% Segment Modiolus

% check for hue (channel 1) wrap-around (bounds are 0->1)
if mod.channel1Min > mod.channel1Max
    mod_mask = ((HSV(:,:,1) >= mod.channel1Min ) | (HSV(:,:,1) <= mod.channel1Max)) & ... 
                (HSV(:,:,2) >= mod.channel2Min ) & (HSV(:,:,2) <= mod.channel2Max)  & ...
                (HSV(:,:,3) >= mod.channel3Min ) & (HSV(:,:,3) <= mod.channel3Max);
else
    mod_mask =  (HSV(:,:,1) >= mod.channel1Min ) & (HSV(:,:,1) <= mod.channel1Max) & ...
                (HSV(:,:,2) >= mod.channel2Min ) & (HSV(:,:,2) <= mod.channel2Max) & ...
                (HSV(:,:,3) >= mod.channel3Min ) & (HSV(:,:,3) <= mod.channel3Max);
end

% find a point on the mask boundary
[ix,iy] = find(mod_mask,1);   

% create polygon from boundary
mod.poly = bwtraceboundarymex(mod_mask, [ix,iy], 8, 4, -1, true); % bypass input checking and call mex directly to run faster
% mod.poly = bwtraceboundary(mod_mask,[ix,iy],'S');
mod.poly_smooth = smoothPolygon(mod.poly, 25);

end
