function [E, EA, mod] = ZsensingSegmentFrameGPU(RGB)
%% ZsensingSegmentFrame  
%  
%
% Auto-generated by colorThresholder app on 04-Feb-2020
% Modified by Trevor Bruns
%------------------------------------------------------

warning('off', 'images:imfindcircles:warnForSmallRadius'); % turn off known warning

%% convert from RGB to HSV

HSV = gpuArray(rgb2hsv(RGB));


%% Thresholds (found using colorThesholder app)

% EA Mask (cyan)
% EA.channel1Min = 0.363;
% EA.channel1Max = 0.552;
% EA.channel2Min = 0.259;
% EA.channel2Max = 1.000;
% EA.channel3Min = 0.729;
% EA.channel3Max = 1.000;
EA.channel1Min = 0.450;
EA.channel1Max = 0.569;
EA.channel2Min = 0.254;
EA.channel2Max = 1.000;
EA.channel3Min = 0.526;
EA.channel3Max = 1.000;
% EA.channel1Min = 0.459;
% EA.channel1Max = 0.548;
% EA.channel2Min = 0.333;
% EA.channel2Max = 1.000;
% EA.channel3Min = 0.000;
% EA.channel3Max = 1.000;

% Modiolus (yellow)
mod.channel1Min = 0.155;
mod.channel1Max = 0.205;
mod.channel2Min = 0.425;
mod.channel2Max = 1.000;
mod.channel3Min = 0.714;
mod.channel3Max = 1.000;

% Electrode 1 (red)
% E(1).channel1Min = 0.983;
% E(1).channel1Max = 0.008;
% E(1).channel2Min = 0.705;
% E(1).channel2Max = 1.000;
% E(1).channel3Min = 0.622;
% E(1).channel3Max = 1.000;

E(1).channel1Min = 0.898;
E(1).channel1Max = 0.034;
E(1).channel2Min = 0.280;
E(1).channel2Max = 1.000;
E(1).channel3Min = 0.327;
E(1).channel3Max = 1.000;

% Electrode 2 (orange)
E(2).channel1Min = 0.030;
E(2).channel1Max = 0.135;
E(2).channel2Min = 0.560;
E(2).channel2Max = 1.000;
E(2).channel3Min = 0.599;
E(2).channel3Max = 1.000;

% Electrode 3 (green)
E(3).channel1Min = 0.329;
E(3).channel1Max = 0.429;
E(3).channel2Min = 0.849;
E(3).channel2Max = 1.000;
E(3).channel3Min = 0.786;
E(3).channel3Max = 1.000;
% E(3).channel1Min = 0.218;
% E(3).channel1Max = 0.479;
% E(3).channel2Min = 0.829;
% E(3).channel2Max = 1.000;
% E(3).channel3Min = 0.870;
% E(3).channel3Max = 1.000;
% E(3).channel1Min = 0.333;
% E(3).channel1Max = 0.450;
% E(3).channel2Min = 0.984;
% E(3).channel2Max = 1.000;
% E(3).channel3Min = 0.949;
% E(3).channel3Max = 1.000;

% Electrode 4 (blue)
E(4).channel1Min = 0.624;
E(4).channel1Max = 0.672;
E(4).channel2Min = 0.958;
E(4).channel2Max = 1.000;
E(4).channel3Min = 0.657;
E(4).channel3Max = 1.000;

% Electrode 5 (magenta)
E(5).channel1Min = 0.771;
E(5).channel1Max = 0.917;
E(5).channel2Min = 0.731;
E(5).channel2Max = 1.000;
E(5).channel3Min = 0.769;
E(5).channel3Max = 1.000;


%% Segment Electrode Markers and Find Centers

for ii=1:length(E)

    % check for hue (channel 1) wrap-around (bounds are 0->1)
    if E(ii).channel1Min > E(ii).channel1Max                                                    
        E_mask = ((HSV(:,:,1) >= E(ii).channel1Min ) | (HSV(:,:,1) <= E(ii).channel1Max)) & ...
                  (HSV(:,:,2) >= E(ii).channel2Min ) & (HSV(:,:,2) <= E(ii).channel2Max)  & ...
                  (HSV(:,:,3) >= E(ii).channel3Min ) & (HSV(:,:,3) <= E(ii).channel3Max);
    else
        E_mask =  (HSV(:,:,1) >= E(ii).channel1Min ) & (HSV(:,:,1) <= E(ii).channel1Max)  & ...
                  (HSV(:,:,2) >= E(ii).channel2Min ) & (HSV(:,:,2) <= E(ii).channel2Max)  & ...
                  (HSV(:,:,3) >= E(ii).channel3Min ) & (HSV(:,:,3) <= E(ii).channel3Max);
    end
    
    E_mask = gather(E_mask);

    % find a point on the mask boundary
%     [ix,iy] = find(E_mask,1);
    
    % create polygon from boundary
    E_boundary = bwboundariesmex(double(E_mask), 8);
    if length(E_boundary)>1
        warning('check boundary segmentation- multiple objects detected')
    end
    E_boundary = E_boundary{1};
%     E_boundary = bwtraceboundarymex(E_mask, [ix,iy], 8, 2, -1, true); % bypass input checking and call mex directly to run faster
%     E_boundary = bwtraceboundary(E_mask,[ix,iy],'S');
    E(ii).center = polygonCentroid(E_boundary);

%     % find circles with radius between [3,8]
%     [E(ii).center, E(ii).radii] = imfindcircles(E_mask,[3 6],'Method','TwoStage');         
%     E(ii).center = fliplr(E(ii).center); % must convert from image 'X/Y' coordinates to pixel 'row/column'
end


%% Segment EA Mask

% check for hue (channel 1) wrap-around (bounds are 0->1)
if EA.channel1Min > EA.channel1Max
    EA_mask = ((HSV(:,:,1) >= EA.channel1Min ) | (HSV(:,:,1) <= EA.channel1Max)) & ... 
               (HSV(:,:,2) >= EA.channel2Min ) & (HSV(:,:,2) <= EA.channel2Max)  & ...
               (HSV(:,:,3) >= EA.channel3Min ) & (HSV(:,:,3) <= EA.channel3Max);
else
    EA_mask =  (HSV(:,:,1) >= EA.channel1Min ) & (HSV(:,:,1) <= EA.channel1Max) & ...
               (HSV(:,:,2) >= EA.channel2Min ) & (HSV(:,:,2) <= EA.channel2Max) & ...
               (HSV(:,:,3) >= EA.channel3Min ) & (HSV(:,:,3) <= EA.channel3Max);
end

EA_mask = gather(EA_mask);

% find a point on the mask boundary
% [ix,iy] = find(EA_mask,1);   

% create polygon from boundary
EA.poly = bwboundariesmex(double(EA_mask), 8);
if length(EA.poly)>1
    warning('check boundary segmentation- multiple objects detected')
end
EA.poly = EA.poly{1};
% EA.poly = bwtraceboundarymex(EA_mask, [ix,iy], 8, 2, -1, true); % bypass input checking and call mex directly to run faster
% EA.poly = bwtraceboundary(EA_mask,[ix,iy],'S');
EA.poly_smooth = smoothPolygon(EA.poly, 25);                  


%% Segment Modiolus

% check for hue (channel 1) wrap-around (bounds are 0->1)
if mod.channel1Min > mod.channel1Max
    mod_mask = ((HSV(:,:,1) >= mod.channel1Min ) | (HSV(:,:,1) <= mod.channel1Max)) & ... 
                (HSV(:,:,2) >= mod.channel2Min ) & (HSV(:,:,2) <= mod.channel2Max)  & ...
                (HSV(:,:,3) >= mod.channel3Min ) & (HSV(:,:,3) <= mod.channel3Max);
else
    mod_mask =  (HSV(:,:,1) >= mod.channel1Min ) & (HSV(:,:,1) <= mod.channel1Max) & ...
                (HSV(:,:,2) >= mod.channel2Min ) & (HSV(:,:,2) <= mod.channel2Max) & ...
                (HSV(:,:,3) >= mod.channel3Min ) & (HSV(:,:,3) <= mod.channel3Max);
end

mod_mask = gather(mod_mask);

% find a point on the mask boundary
% [ix,iy] = find(mod_mask,1);   

% create polygon from boundary
mod.poly = bwboundariesmex(double(mod_mask), 8);
if length(mod.poly)>1
    warning('check boundary segmentation- multiple objects detected')
end
mod.poly = mod.poly{1};
% mod.poly = bwtraceboundarymex(mod_mask, [ix,iy], 8, 2, -1, true); % bypass input checking and call mex directly to run faster
% mod.poly = bwtraceboundary(mod_mask,[ix,iy],'S');
mod.poly_smooth = smoothPolygon(mod.poly, 25);

end
